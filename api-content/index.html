{"posts":[{"title":"Openssl \"Heartbleed\" 漏洞分析","content":"title:&quot;&quot;date:2014-04-15T20:56:27+08:00draft:false#Openssl&quot;heartbleed&quot;漏洞漏洞在4.8爆发的那天就看过漏洞分析，但是太浮躁又对openssl了解不是很深，就没能看懂，今天下载了openssl源码，查了些资料。总算对‘heartbleed’漏洞有个完整的认识。###ssl简要原理与心跳包ssl是为网络通信提供安全的一种协议，建立在tcp连接之上，对通信双方身份进行认证并加密传输数据。结构如图：上层是ssl握手层：协商密钥，加密算法等，对双方进行身份认证，同时包含传输的数据。下层是ssl记录层：通过握手层确定的安全参数对数据进行封装，同时通过数据格式来检测消息的完整性。心跳包就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。而ssl中的Heartbeat‘心跳包’存在与握手层。数据格式包括：心跳包类型(type)，载荷长度(length),载荷(payload),填充(padding).###漏洞分析结合乌云知识库文章关于openssl“心脏出血”漏洞的分析。下载到存在漏洞的openssl版本为openssl-1.0.1f。存在漏洞的有两个文件ssl/d1_both.c和ssl/t1_lib.c。而乌云的分析文章不但把文件名搞错（d后面是数字1而不是字母l），而且分析的是前者，基于UDP的TLS，而后者才是常用的TCP（无影响的细节...）Ok~开始分析。####1.ssl3记录格式和两个宏。typedefstructssl3_record_st{/*r*/inttype;/*typeofrecord*//*rw*/unsignedintlength;/*Howmanybytesavailable*//*r*/unsignedintoff;/*read/writeoffsetinto'buf'*//*rw*/unsignedchar*data;/*pointertotherecorddata*//*rw*/unsignedchar*input;/*wherethedecodebytesare*//*r*/unsignedchar*comp;/*onlyusedwithdecompression-malloc()ed*//*r*/unsignedlongepoch;/*epochnumber,neededbyDTLS1*//*r*/unsignedcharseq_num[8];/*sequencenumber,neededbyDTLS1*/}SSL3_RECORD;该文件位于ssl/ssl3.h中，该文件定义了sslv3记录的各种数据格式，只看对后面比较关键的数据类型：type：1字节。表示请求类型，01表示请求，02表示回应。Length：2字节。保存数据的长度后面全部：各种数据。。#definen2s(c,s)((s=(((unsignedint)(c[0]))&amp;lt;&amp;lt;8)|\\(((unsignedint)(c[1])))),c+=2)#defines2n(s,c)((c[0]=(unsignedchar)(((s)&amp;gt;&amp;gt;8)&amp;amp;0xff),\\c[1]=(unsignedchar)(((s))&amp;amp;0xff)),c+=2)两个宏，位于ssl/ssl_locl.h，心跳处理函数中将使用，可以看出n2s把char数组s中的前两个字节转为unsignedint类型并保存进c。s2n做相反的事情。####2.心跳处理函数。inttls1_process_heartbeat(SSL*s){unsignedchar*p=&amp;amp;s-&amp;gt;s3-&amp;gt;rrec.data[0],*pl;unsignedshorthbtype;unsignedintpayload;unsignedintpadding=16;/*Useminimumpadding*//*Readtypeandpayloadlengthfirst*/hbtype=*p++;n2s(p,payload);pl=p;指针p指向上面提到的ssl3数据结构。hbtype：保存心跳包类型，包括请求与响应两个格式；payload：保存荷载长度，就是客户端发送的数据的长度，而服务器把同样长度的数据返回去padding：填充，负责把一个ssl记录给填满；获取心跳包类型放入hbtype把p现在所指的的数据取出两个字节放入payload，也就是length的值。Pl指向后面的数据if(hbtype==TLS1_HB_REQUEST){unsignedchar*buffer,*bp;intr;/*Allocatememoryfortheresponse,sizeis1bytes*messagetype,plus2bytespayloadlength,plus*payload,pluspadding*/buffer=OPENSSL_malloc(1+2+payload+padding);bp=buffer;如果数据类型是请求，便申请内存，大小为:1（type）+2（length）+payload（数据的长度）+padding（填充值）注意到这里的payload是由length的值所给定的，并不一定是数据的真实长度，漏洞就此埋下伏笔。bp指向这段内存。/*Enterresponsetype,lengthandcopypayload*/*bp++=TLS1_HB_RESPONSE;s2n(payload,bp);memcpy(bp,pl,payload);bp+=payload;/*Randompadding*/RAND_pseudo_bytes(bp,padding);开始对数据包进行响应，将回应类型（type)放入bp的第一个字节，s2n如上所知，和n2s相反，把payload的值填充到bp的第二三个字节。重头戏到了，memcpy函数，把从pl后的payload字节放入bp中，而payload的值根本无法确定是数据的真实长度，而是由length给定的。如果实际的payload小于length的值，便会向后寻找数据填充。漏洞就此产生~###漏洞利用先简单看下利用脚本。hb是构造的心跳包，01代表请求类型，4000是length的值，这里4000化为2进制为16384共16kb，其实完全可以ffff这样一次可以得到64kb的数据。PoC的整体思路：使用socket创建TCP连接-&gt;建立ssl握手（发送Clienthello包和接受ServerHello包）-&gt;发送恶意heartbeat包-&gt;输出异常数据。具体实现细节就不分析了。可以将脚本进行一些改动，比如循环遍历数据，格式化保存数据，再加上循环ip范围段实现自动化检测和利用等等。###漏洞修复。漏洞产生的原因很简单，所以修补起来也很容易，找到修补后的openssl-1.0.1g版本。/*Readtypeandpayloadlengthfirst*/if(1+2+16&amp;gt;s-&amp;gt;s3-&amp;gt;rrec.length)return0;/*silentlydiscard*/hbtype=*p++;n2s(p,payload);if(1+2+payload+16&amp;gt;s-&amp;gt;s3-&amp;gt;rrec.length)return0;/*silentlydiscardperRFC6520sec.4*/pl=p;代码首先对心跳包的数据是否为零进行判断，16为padding填充值的最小长度，1+2+16为一个心跳包中必有的参数（不包括数据）,然后对心跳包的长度是否足够进行判断。就是那么简单~###一些安全思考。安全的本质是信任问题。每个漏洞都在体现这个本质，而在这次漏洞中，就是信任了length的值，但是这个信任基础被打破，黑客可以修改length值构造数据包进行攻击。又一个缓冲区溢出。我觉得这个年代缓冲区溢出已经很少见了，但是这个漏洞机制如此简单，对内存的申请如此随意，表现出来的安全意识实在有些薄弱。逃过日志记录的入侵。日志对于安全监测的重要性的不言而喻。但是服务器不记录heartbeat包异常，所造成的危害也就完全无法估量。虽然记录每个心跳包的话显得过于庞大，但是可以按一定规则记录心跳包的发送频率的吧，起码能让whiletrue这种无脑dump数据有些作用。实现不遵循协议。RFC6520中规定了heartbeat包的长度不能超过2^14（16384），如果数据过长，这个heartbeat请求应该被丢弃（所以PoC的作者把length值设为4000）。Openssl只在发送请求的客户端进行了检查，否则每次泄漏内存只是16kb而不是64kb。虽然这对于漏洞的信息泄漏没有多少限制（whiletrue。。。），但是不遵循协议带来安全隐患是没法预测的。对基础设施的安全关注度不够。作为让网络变得更安全的安全产品，却自身出现了问题，才会在网络上掀起轩然大波，但看到openssl开发团队人数之少，经费之短缺，很难把责任都推向他们。一个安全的互联网，不应该只是靠一些人的努力。###一些疑惑。PoC里心跳包的第一排数据是什么东西，sslv3记录格式一开始就是数据类型的呀。Length值的存在意义，如果要使用到一段数据的长度值，为啥还要对其进行一个声明，对它直接进行验证并保存进length里面难道不是一个很好的办法？不知道这是ssl协议的要求还是openssl实现的做法。为什么一次能泄漏的数据是64kb。一开始以为是memcpy函数的限制，后来没查到资料。但是查到应该是C的编译限制，C源程序编译生成的代码和数据量都不能超过64KB。待确认。随机读取内存获得敏感信息的几率。测试结果让我很吃惊，几乎每次请求都能得到敏感数据，现在甚至有成功恢复密钥的消息。不知道为什么SSLv3记录附近能有这么多的好东西。乌云文章里称C语言的局限性很大，安全编程很难。我的理解是C语言的内存的操控太灵活，使得容易出问题。其他方面还不能很好的领悟。附：网上找到的一幅对漏洞原理说的很形象的漫画","link":"https://pikez.github.io/post/openssl-heartbleed-lou-dong-fen-xi/"}]}